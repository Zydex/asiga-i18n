/*! Li18nt 5.0.0 MIT | https://github.com/Simonwep/li18nt */
function e(e){switch(typeof e){case"undefined":return"undefined";case"object":return Array.isArray(e)?"array":null===e?"null":"object";case"boolean":return"boolean";case"number":return"number";case"string":return"string"}}const t=/(\.|^)([a-zA-Z]\w*|\*)|\[(\d+|'(.*?)'|"(.*?)")]/g,n=(e,t)=>{e:for(const n of e)if(n.length<=t.length){for(let e=0;e<n.length;e++){const r=n[e];if("*"===r)return!0;if(r!==t[e])continue e}return!0}return!1};const r=(e,t)=>!((e,t)=>{e:for(const n of e)if(n.length===t.length){for(let r=0;r<e.length;r++)if(n[r]!==t[r])continue e;return!0}return!1})(e,t)&&(e.push(t),!0),o=(t,n)=>{const o={conflicts:[],missing:[]};function s(t,n,s,i=[]){const l=n[t],a=e(l);if("undefined"!==a)for(const n of s){const s=n[t],f=e(s);if("undefined"!==f)if(f===a)if("object"!==f||f!==a){if("array"===f){if(l.length!=l.length){r(o.conflicts,[...i,t]);continue}c(l,s,[...i,t])}}else c(l,[s],[...i,t]);else r(o.conflicts,[...i,t])}else r(o.missing,[...i,t])}function c(e,t,n=[]){if(Array.isArray(e)&&Array.isArray(t)){const r=Math.max(e.length,t.length);for(let o=0;o<r;o++)s(o,e,t,n)}else for(const o of(r=[e,...t],new Set(r.map((e=>Object.keys(e))).flat())))s(o,e,t,n);var r}return c(t,n),o},s=e=>{const t=[];for(let n=0;n<e.length;n++){const r=e[n],s=[...e];s.splice(n,1),t.push(o(r,s))}return t},c=(r,o)=>{var s;const c=new Map,i=new Map,l=(null===(s=null==o?void 0:o.ignore)||void 0===s?void 0:s.map((e=>Array.isArray(e)?e:(e=>{const n=[];let r,o;for(;o=t.exec(e);){const[e,,t,s,c,i]=o,l=t||c||i;r=o.index+e.length,l?n.push(l):s&&n.push(Number(s))}if(r!==e.length)throw new Error(`Cannot parse "${e}", invalid character at index ${r}.`);return n})(e))))||[],a=(t,r)=>{if(Array.isArray(t))for(let n=0;n<t.length;n++){const o=t[n];"object"===e(o)&&a(o,[...r,n])}else for(const o in t)if(Object.prototype.hasOwnProperty.call(t,o)){const s=[...r,o],f=t[o],u=e(f);if("object"===u||"array"===u){n(l,s)||a(f,s);continue}const h=i.get(o);if(h){const e=c.get(o)||[h];n(l,s)||c.set(o,[...e,s])}else i.set(o,s)}};return a(r,[]),c},i=(t,n)=>{const r=[],o=((null==n?void 0:n.patterns)||[]).map((e=>e instanceof RegExp?e:new RegExp(e)));for(const{key:n,path:s}of function*(t,n){yield*function*t(r,o=[]){if(Array.isArray(r))for(let s=0;s<r.length;s++){const c=[...o,s],i=r[s];switch(n||(yield{path:c,key:s}),e(i)){case"array":case"object":yield*t(i,c)}}else for(const[n,s]of Object.entries(r)){const r=[...o,n];switch(yield{path:r,key:n},e(s)){case"array":case"object":yield*t(s,r)}}}(t)}(t,!0)){const e=o.filter((e=>!e.test(n)));e.length&&r.push({failed:e.map((e=>e.toString())),key:n,path:s})}return r},l=e=>Object.keys(e).sort(((e,t)=>e===t?0:e.localeCompare(t))),a=(t,{indent:n=4})=>{const r="tab"===n?"\t":" ".repeat(n);let o="{\n";const s=(t,n)=>{const o=e(t),c=n+r;switch(o){case"object":{let e="{\n";for(const n of l(t))e+=`${c}"${n}": ${s(t[n],c)},\n`;return e.length>2?`${e.slice(0,e.length-2)}\n${n}}`:"{}"}case"array":{let e="[\n";for(let n=0;n<t.length;n++)e+=`${c+s(t[n],c)},\n`;return e.length>2?`${e.slice(0,e.length-2)}\n${n}]`:"[]"}case"boolean":case"number":case"null":return t;case"string":return JSON.stringify(t)}return null};for(const e of l(t))o+=`${r}"${e}": ${s(t[e],r)},\n`;return o.length>2?`${o.slice(0,o.length-2)}\n}`:"{}"},f="5.0.0",u=(e,t)=>{const n={};if(e.naming){const r=[];for(const n of t)r.push(i(n,e.naming));n.naming=r}if(e.conflicts&&(n.conflicts=s(t)),e.duplicates){const r="boolean"==typeof e.duplicates?{}:e.duplicates;n.duplicates=[];for(const e of t)n.duplicates.push(c(e,r))}if(void 0!==e.prettified){const r="object"!=typeof e.prettified?{indent:e.prettified}:e.prettified;n.prettified=[];for(const e of t)n.prettified.push(a(e,r))}return n};export{s as conflicts,c as duplicates,u as lint,i as pattern,a as prettify,f as version};
//# sourceMappingURL=index.min.mjs.map
